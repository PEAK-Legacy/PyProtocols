=========================
Custom Result Combination
=========================

Sometimes, the default strategy of selecting the "most-specific" method or
result is inadequate for a particular task.  You may therefore wish to
implement custom result combining strategies by subclassing ``Dispatcher`` or
``GenericFunction``, and overriding the ``combine()`` method as appropriate.

    >>> from dispatch import strategy, functions, combiners



Map Dispatchers
===============

Map dispatchers are typically used for class and attribute metadata, such as
command line options associated with a class' attributes.  Map dispatchers
merge the metadata that was defined for a class and its ancestors, detecting
any ambiguities between specific metadata items defined in different base
classes, or defined by multiple rules for the same class.  (Actually, they use
normal implication precedence, but for simple metadata registries, this usually
maps directly to the inheritance structure of the target classes.)

In essence, one defines the metadata as a set of keys and values.  The map
combiner builds a map of the "most specific" applicable values.  The keys and
values are extracted from each applicable rule or method in the dispatcher or
generic function, and then they are merged in precedence order.  If there are
two rules at the same precedence level, and they share any keys, the values
they provide for those keys must be equal, or an ambiguity occurs.  (Unless,
that is, those keys were already unambiguously defined at a higher precedence
level.)

To start, we'll define a basic class hierarchy, shaped basically like this::

            A
           / \
          B   C
           \ /
            D

By creating these classes, and some signatures to use in their place::

    >>> class A: pass
    >>> class B(A): pass
    >>> class C(A): pass
    >>> class D(B,C): pass

    >>> a = strategy.Signature(x=A)
    >>> b = strategy.Signature(x=B)
    >>> c = strategy.Signature(x=C)
    >>> d = strategy.Signature(x=D)
    
Our example map combiner will use functions as its rules, with function
attributes serving as keys and values.  We'll define some functions that have
the same keys but different values, some with the same keys and same values,
and some with different keys.  And, we'll also create a rule that means
"ignore any lower-precedence rules"::

    >>> def r1(): pass
    >>> r1.key_a = 1

    >>> def r2(): pass
    >>> r2.key_a = 2        # same key, different value

    >>> def r3(): pass
    >>> r3.key_a = 2        # same key, same value

    >>> def r4(): pass
    >>> r4.key_a = 4        # same key, different value
    >>> r4.key_b = 42       # different key

    >>> def r5(): pass
    >>> r5.stop = True      # "stop processing rules"

Next, we'll need a ``MapDispatcher`` subclass that can interpret this rule
schema::

    >>> class ExampleDispatcher(combiners.MapDispatcher):
    ...     def getItems(self,signature,rule):
    ...         # get function attributes
    ...         return [kv for kv in rule.__dict__.items() if kv[0]<>'stop']
    ...     def shouldStop(self,signature,rule):
    ...         return getattr(rule,'stop',False)

And we need an instance of it to use as a dispatcher, whose ``combine`` method
we'll be testing::

    >>> disp = ExampleDispatcher(['x'])
    >>> combine = disp.combine

In the simplest possible case, combining no results should return an empty
dictionary::

    >>> combine([])
    {}

And supplying a single result will return a dictionary containing that rule's
attributes::

    >>> combine([(a,r1)])
    {'key_a': 1}
    >>> combine([(a,r4)])
    {'key_a': 4, 'key_b': 42}

When supplying more than one result, the one with higher precedence should
take effect, regardless of the order in which they are supplied::

    >>> combine([(b,r2),(a,r1)])    # most-specific first
    {'key_a': 2}
    >>> combine([(a,r1),(b,r2)])    # least-specific first
    {'key_a': 2}

And values for keys on lower-precedence rules should still "show through"
if there is no higher-precedence value defined for a given key::

    >>> combine([(b,r2),(a,r4)])
    {'key_a': 2, 'key_b': 42}

But rules at the same precedence levels with the same keys should produce
an error::

    >>> combine([(b,r1),(c,r2)])
    Traceback (most recent call last):
    ...
    AmbiguousMethod...

Unless of course the keys have the same values::

    >>> combine([(b,r2),(c,r3)])
    {'key_a': 2}
    >>> combine([(b,r2),(c,r3),(a,r4)])  # should still merge other key
    {'key_a': 2, 'key_b': 42}

Or the conflicting key is already given a value with higher precedence::

    >>> combine([(b,r1),(c,r2),(d,r4)])
    {'key_a': 4, 'key_b': 42}

Or if a "stop" is requested at a higher precedence::

    >>> combine([(b,r1),(c,r2),(d,r5)])
    {}

Notice that once a "stop" takes effect, no lower-precedence rules are handled::

    >>> combine([(c,r1),(b,r5),(a,r4)])
    {'key_a': 1}

So, now that we've verified that our ``combine()`` method works, we should be
able to use our dispatcher as if it were a normal ``Dispatcher`` instance
(but which provides appropriately-combined results)::

    >>> disp["x in A"] = r4
    >>> disp["x in B"] = r1
    >>> disp["x in C"] = r2
    >>> disp["x in D"] = r3

    >>> disp[A(),]
    {'key_a': 4, 'key_b': 42}
    >>> disp[B(),]
    {'key_a': 1, 'key_b': 42}
    >>> disp[C(),]
    {'key_a': 2, 'key_b': 42}
    >>> disp[D(),]
    {'key_a': 2, 'key_b': 42}

Voila!  Now we can make direct use of the metadata mapping that's returned
by the dispatcher for an instance of a given class.  Note, by the way, that
the results are cached by the dispatcher, so a given set of methods is only
combined once (unless new methods are added or criteria such as protocols are
updated)::

    >>> disp[D(),] is disp[D(),]    # same object returned from two calls
    1

