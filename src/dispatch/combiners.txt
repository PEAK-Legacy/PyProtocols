==================
Result Combination
==================

Sometimes, the default strategy of selecting the "most-specific" method or
result is inadequate for a particular task.  You may therefore wish to
implement custom result combining strategies by subclassing ``Dispatcher`` or
``GenericFunction``, and overriding the ``combine()`` method as appropriate.

However, the ``dispatch.combiners`` module provides an assortment of useful
already-written result combinations, which we will also cover here.

>>> from dispatch import strategy, functions, combiners, NoApplicableMethods



Default Result Combination
==========================

XXX need test for default Dispatcher combination strategy (i.e. most-specific
only)


Before/After/Around Methods
===========================

* Filter by qualifier (qualify(s,f) -> s,(q,f) -> {q: [(s,f)]})

* Invoke before before, after after


Custom Result Combination
=========================

To implement a custom result combination, you will subclass ``Dispatcher``
or ``GenericFunction``, as appropriate, and overide the ``combine()`` method
to implement your result combination algorithm.

The ``combine()`` method takes one argument: a sequence of ``(signature,res)``
tuples (also known as "cases"), where ``res`` is either a dispatcher result or
a generic function method, and ``signature`` is an ``ISignature`` describing
the condition under which that result or method should apply.  The
``combine()`` method must then return a single callable (for generic functions)
or a single result (for dispatcher classes).  It may raise ``AmbiguousMethod``
or ``NoApplicableMethods`` to indicate an error condition.

Initially, the input sequence will be in definition order.  That is, each
case (``(signature,res)`` pair) will appear in the order it was added to the
dispatcher or generic function.  It is up to the ``combine()`` method to do
any re-ordering or sorting desired.  For your convenience, the
``dispatch.strategy`` module includes several useful functions for sorting,
filtering, and combining methods from the input sequence.


Method Combination Utilities
----------------------------

The following method combination utilities are available from the
``dispatch.strategy`` module.  They can be assembled in various ways to
create interesting method combinations:

``ordered_signatures(cases)``
    Yields a series of cases grouped by specificity, such that each group
    is a set of equally-specific cases, but which are more specific than the
    cases in groups that follow.  The grouped cases can then be passed to
    ``safe_methods()`` or ``all_methods()`` in order to extract methods for
    combining.

    Note that groups containing more than one case are *ambiguous*.  That is,
    it is not statically determinable which cases are more specific than the
    others.  In general, a dispatcher should raise ``AmbiguousMethod`` if the
    first group yielded by this function has a length greater than 1.

``safe_methods(grouped_cases)``
    Yields methods from the grouped cases until an ambiguous group is found or
    the input is exhausted.  An ambiguous group in the input will be replaced
    by a callable in the output that raises ``AmbiguousMethod`` when called.

    >>> list(strategy.safe_methods([]))
    []
    >>> list(strategy.safe_methods([[(1,2)],[(3,4)],[(5,6)]]))
    [2, 4, 6]
    >>> list(strategy.safe_methods([[(1,2)],[(3,4),(5,6)]]))
    [2, <function ambiguous at ...>]


``all_methods(grouped_cases)``
    Yields all methods from the grouped cases, including ones in ambiguous
    groups.

    >>> list(strategy.all_methods([]))
    []
    >>> list(strategy.all_methods([[(1,2)],[(3,4),(5,6)]]))
    [2, 4, 6]


``method_chain(methods)``
    Returns a callable that invokes the first method in ``methods``.  If
    that method has a ``next_method`` parameter, then when called it will be
    passed an extra argument, pointing to the next applicable method in
    ``methods``, and so on recursively, until a method without a
    ``next_method`` parameter is reached.  (Thus, if the first method in
    ``methods`` does not have a ``next_method`` parameter, it is returned
    directly.)  If there are no methods in ``methods``, then a dummy method
    is returned that raises ``NoApplicableMethods`` when called.

    >>> def f1(next_method): print "f1"; return next_method()
    >>> def f2(next_method): print "f2"; return next_method()
    >>> def f3(): print "f3"; return "done"

    >>> strategy.method_chain([f1,f2,f3])()
    f1
    f2
    f3
    'done'

    >>> strategy.method_chain([])()
    Traceback (most recent call last):
    ...
    NoApplicableMethods...


``method_list(methods)``
    Returns a callable that when called, yields the results of calling each of
    the supplied methods in turn with the same arguments:

    >>> def f1(x): return "f1"+x
    >>> def f2(x): return "f2"+x
    >>> for item in strategy.method_list([f1,f2])("y"): print item
    f1y
    f2y
    >>> list(strategy.method_list([])()) # empty method list yields no results
    []




Map Dispatchers
===============

Map dispatchers are typically used for class and attribute metadata, such as
command line options associated with a class' attributes.  Map dispatchers
merge the metadata that was defined for a class and its ancestors, detecting
any ambiguities between specific metadata items defined in different base
classes, or defined by multiple rules for the same class.  (Actually, they use
normal implication precedence, but for simple metadata registries, this usually
maps directly to the inheritance structure of the target classes.)

In essence, one defines the metadata as a set of keys and values.  The map
combiner builds a map of the "most specific" applicable values.  The keys and
values are extracted from each applicable rule or method in the dispatcher or
generic function, and then they are merged in precedence order.  If there are
two rules at the same precedence level, and they share any keys, the values
they provide for those keys must be equal, or an ambiguity occurs.  (Unless,
that is, those keys were already unambiguously defined at a higher precedence
level.)

To start, we'll define a basic class hierarchy, shaped basically like this::

            A
           / \
          B   C
           \ /
            D

By creating these classes, and some signatures to use in their place::

    >>> class A: pass
    >>> class B(A): pass
    >>> class C(A): pass
    >>> class D(B,C): pass

    >>> a = strategy.Signature(x=A)
    >>> b = strategy.Signature(x=B)
    >>> c = strategy.Signature(x=C)
    >>> d = strategy.Signature(x=D)

Our example map combiner will use functions as its rules, with function
attributes serving as keys and values.  We'll define some functions that have
the same keys but different values, some with the same keys and same values,
and some with different keys.  And, we'll also create a rule that means
"ignore any lower-precedence rules"::

    >>> def r1(): pass
    >>> r1.key_a = 1

    >>> def r2(): pass
    >>> r2.key_a = 2        # same key, different value

    >>> def r3(): pass
    >>> r3.key_a = 2        # same key, same value

    >>> def r4(): pass
    >>> r4.key_a = 4        # same key, different value
    >>> r4.key_b = 42       # different key

    >>> def r5(): pass
    >>> r5.stop = True      # "stop processing rules"

Next, we'll need a ``MapDispatcher`` subclass that can interpret this rule
schema::

    >>> class ExampleDispatcher(combiners.MapDispatcher):
    ...     def getItems(self,signature,rule):
    ...         # get function attributes
    ...         return [kv for kv in rule.__dict__.items() if kv[0]<>'stop']
    ...     def shouldStop(self,signature,rule):
    ...         return getattr(rule,'stop',False)

And we need an instance of it to use as a dispatcher, whose ``combine`` method
we'll be testing::

    >>> disp = ExampleDispatcher(['x'])
    >>> combine = disp.combine

In the simplest possible case, combining no results should return an empty
dictionary::

    >>> combine([])
    {}

And supplying a single result will return a dictionary containing that rule's
attributes::

    >>> combine([(a,r1)])
    {'key_a': 1}
    >>> combine([(a,r4)])
    {'key_a': 4, 'key_b': 42}

When supplying more than one result, the one with higher precedence should
take effect, regardless of the order in which they are supplied::

    >>> combine([(b,r2),(a,r1)])    # most-specific first
    {'key_a': 2}
    >>> combine([(a,r1),(b,r2)])    # least-specific first
    {'key_a': 2}

And values for keys on lower-precedence rules should still "show through"
if there is no higher-precedence value defined for a given key::

    >>> combine([(b,r2),(a,r4)])
    {'key_a': 2, 'key_b': 42}

But rules at the same precedence levels with the same keys should produce
an error::

    >>> combine([(b,r1),(c,r2)])
    Traceback (most recent call last):
    ...
    AmbiguousMethod...

Unless of course the keys have the same values::

    >>> combine([(b,r2),(c,r3)])
    {'key_a': 2}
    >>> combine([(b,r2),(c,r3),(a,r4)])  # should still merge other key
    {'key_a': 2, 'key_b': 42}

Or the conflicting key is already given a value with higher precedence::

    >>> combine([(b,r1),(c,r2),(d,r4)])
    {'key_a': 4, 'key_b': 42}

Or if a "stop" is requested at a higher precedence::

    >>> combine([(b,r1),(c,r2),(d,r5)])
    {}

Notice that once a "stop" takes effect, no lower-precedence rules are handled::

    >>> combine([(c,r1),(b,r5),(a,r4)])
    {'key_a': 1}

So, now that we've verified that our ``combine()`` method works, we should be
able to use our dispatcher as if it were a normal ``Dispatcher`` instance
(but which provides appropriately-combined results)::

    >>> disp["x in A"] = r4
    >>> disp["x in B"] = r1
    >>> disp["x in C"] = r2
    >>> disp["x in D"] = r3

    >>> disp[A(),]
    {'key_a': 4, 'key_b': 42}
    >>> disp[B(),]
    {'key_a': 1, 'key_b': 42}
    >>> disp[C(),]
    {'key_a': 2, 'key_b': 42}
    >>> disp[D(),]
    {'key_a': 2, 'key_b': 42}

Voila!  Now we can make direct use of the metadata mapping that's returned
by the dispatcher for an instance of a given class.  Note, by the way, that
the results are cached by the dispatcher, so a given set of methods is only
combined once (unless new methods are added or criteria such as protocols are
updated)::

    >>> disp[D(),] is disp[D(),]    # same object returned from two calls
    1

