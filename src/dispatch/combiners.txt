================
Method Combiners
================

    >>> from dispatch import strategy, functions, combiners



Map Combiners
=============

Map combiners are typically used for class and attribute metadata, such as
command line options associated with a class' attributes.  Map combiners merge
the metadata that was defined for a class and its ancestors, detecting any
ambiguities between specific metadata items defined in different base classes,
or defined by multiple rules for the same class.  (Actually, they use normal
implication precedence, but for simple metadata registries, this usually maps
directly to the inheritance structure of the target classes.)

In essence, one defines the metadata as a set of keys and values.  The map
combiner builds a map of the "most specific" applicable values.  The keys and
values are extracted from each applicable rule or method in the dispatcher or
generic function, and then they are merged in precedence order.  If there are
two rules at the same precedence level, and they share any keys, the values
they provide for those keys must be equal, or an ambiguity occurs.  (Unless,
that is, those keys were already unambiguously defined at a higher precedence
level.)

To start, we'll define a basic class hierarchy, shaped basically like this::

            A
           / \
          B   C
           \ /
            D

By creating these classes, and some signatures to use in their place::

    >>> class A: pass
    >>> class B(A): pass
    >>> class C(A): pass
    >>> class D(B,C): pass

    >>> a = strategy.Signature(x=A)
    >>> b = strategy.Signature(x=B)
    >>> c = strategy.Signature(x=C)
    >>> d = strategy.Signature(x=D)
    
Our example map combiner will use functions as its rules, with function
attributes serving as keys and values.  We'll define some functions that have
the same keys but different values, some with the same keys and same values,
and some with different keys.  And, we'll also create a rule that means
"ignore any lower-precedence rules"::

    >>> def r1(): pass
    >>> r1.key_a = 1

    >>> def r2(): pass
    >>> r2.key_a = 2        # same key, different value

    >>> def r3(): pass
    >>> r3.key_a = 2        # same key, same value

    >>> def r4(): pass
    >>> r4.key_a = 4        # same key, different value
    >>> r4.key_b = 42       # different key

    >>> def r5(): pass
    >>> r5.stop = True      # "stop processing rules"

Next, we'll need a ``MapCombiner`` subclass that can interpret this rule
schema::

    >>> class ExampleCombiner(combiners.MapCombiner):
    ...     def getItems(self,signature,rule):
    ...         # get function attributes
    ...         return [kv for kv in rule.__dict__.items() if kv[0]<>'stop']
    ...     def shouldStop(self,signature,rule):
    ...         return getattr(rule,'stop',False)

In the simplest possible case, creating an ``ExampleCombiner`` with no methods
will return an empty dictionary::

    >>> ExampleCombiner([])
    {}

And supplying a single method will return a dictionary containing that rule's
attributes::

    >>> ExampleCombiner([(a,r1)])
    {'key_a': 1}
    >>> ExampleCombiner([(a,r4)])
    {'key_a': 4, 'key_b': 42}

When supplying more than one method, the one with higher precedence should
take effect, regardless of the order in which they are supplied::

    >>> ExampleCombiner([(b,r2),(a,r1)])    # most-specific first
    {'key_a': 2}
    >>> ExampleCombiner([(a,r1),(b,r2)])    # least-specific first
    {'key_a': 2}

And values for keys on lower-precedence methods should still "show through"
if there is no higher-precedence value defined for a given key::

    >>> ExampleCombiner([(b,r2),(a,r4)])
    {'key_a': 2, 'key_b': 42}

But rules at the same precedence levels with the same keys should produce
an error::

    >>> ExampleCombiner([(b,r1),(c,r2)])
    Traceback (most recent call last):
    ...
    AmbiguousMethod...

Unless of course the keys have the same values::

    >>> ExampleCombiner([(b,r2),(c,r3)])
    {'key_a': 2}
    >>> ExampleCombiner([(b,r2),(c,r3),(a,r4)])  # should still merge other key
    {'key_a': 2, 'key_b': 42}

Or the conflicting key is already given a value with higher precedence::

    >>> ExampleCombiner([(b,r1),(c,r2),(d,r4)])
    {'key_a': 4, 'key_b': 42}

Or if a "stop" is requested at a higher precedence::

    >>> ExampleCombiner([(b,r1),(c,r2),(d,r5)])
    {}

Notice that once a "stop" takes effect, no lower-precedence rules are handled::

    >>> ExampleCombiner([(c,r1),(b,r5),(a,r4)])
    {'key_a': 1}

So, now that our combiner works, we should be able to use it to control a
``Dispatcher``::

    >>> disp = functions.Dispatcher(['x'], ExampleCombiner)
    >>> disp["x in A"] = r4
    >>> disp["x in B"] = r1
    >>> disp["x in C"] = r2
    >>> disp["x in D"] = r3
    >>> disp[A(),]
    {'key_a': 4, 'key_b': 42}
    >>> disp[B(),]
    {'key_a': 1, 'key_b': 42}
    >>> disp[C(),]
    {'key_a': 2, 'key_b': 42}
    >>> disp[D(),]
    {'key_a': 2, 'key_b': 42}

Voila!  Now we can make direct use of the metadata mapping that's returned
by the dispatcher for an instance of a given class.  Note, by the way, that
the results are cached by the dispatcher, so a given set of methods is only
combined once (unless new methods are added or criteria such as protocols are
updated)::

    >>> disp[D(),] is disp[D(),]    # same object returned from two calls
    1

