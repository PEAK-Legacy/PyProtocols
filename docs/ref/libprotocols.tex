\section{\module{protocols} ---
         Protocol Definition, Declaration, and Adaptation}
\declaremodule{}{protocols}
\moduleauthor{Phillip J. Eby}{pje@telecommunity.com}
\sectionauthor{Phillip J. Eby}{pje@telecommunity.com}
\modulesynopsis{Protocol declaration and adaptation functions as described in
    PEP XXX.}

\begin{quotation}
The typical Python programmer is an integrator, someone who is
connecting components from various vendors.  Often times the
interfaces between these components require an intermediate
adapter.  Usually the burden falls upon the programmer to
study the interface exposed by one component and required by
another, determine if they are directly compatible, or develop
an adapter.  Sometimes a vendor may even include the
appropriate adapter, but then searching for the adapter and
figuring out how to deploy the adapter takes time.

\hfill --- Martelli \& Evans, PEP 246
\end{quotation}

This package builds on the object adaptation protocol presented in \pep{246}
to make it easier for component authors, framework suppliers, and other
developers to:

\begin{itemize}

\item Specify what behavior a component requires or provides

\item Specify how to adapt the interface provided by one component to that
required by another

\item Specify how to adapt objects of a particular type or class (even
built-in types) to a particular required interface

\item Automatically adapt a supplied object to a required interface, and

\item Do all of the above, even when the components or frameworks involved
were not written to take advantage of this package, and even if the frameworks
have different mechanisms for defining interfaces.

\end{itemize}

Assuming that a particular framework either already supports this package, or
has been externally adapted to do so, then framework users will typically
use this package's declaration API to declare what interfaces their classes or
objects provide, and/or to declare adaptations between interfaces or
components.

For framework developers, this package offers an opportunity to replace
tedious and repetitive type-checking code (such as \function{isinstance()},
\function{type()}, \function{hasattr()}, or interface checks) with single
calls to \function{adapt()} instead.  In addition, if the framework has
objects that represent interfaces or protocols, the framework developer can
make them usable with this package's declaration API by adding adapters for
(or direct implementations of) the \class{IOpenProtocol} interface provided
herein.

If the developer of a framework does not do these things, it may still be
possible for a framework user or third-party developer to do them, in order to
be able to use this package's API.  The user of a framework can often call
\function{adapt()} on a component before passing it to a non-adapting
framework.  And, it's possible to externally adapt a
framework's interface objects as well.

For example, the \module{protocols.classic} module includes an adapter that
implements \class{IOpenProtocol} on behalf of Zope \class{Interface}
objects.  This allows them to be used as arguments to this package's protocol
declaration API.  This works even though Zope is completely unaware of the
\module{protocols} package.  (Of course, this does not give Zope
\class{Interface} objects all of the capabilities that \class{Protocol}
objects have, but it does make their existing functionality accessible
through the same API.)

Finally, framework and non-framework developers alike may also wish to use the
\class{Protocol} and \class{Interface} base classes from this package to
define protocols or interfaces of their own, or perhaps use some of the
adaptation mechanisms supplied here to implement ``double dispatching'' or
the ``visitor pattern''.


\begin{seealso}

\seepep{246}{Object Adaptation}{PEP 246 describes an early version of the 
adaptation protocol used by this package.}

\end{seealso}

\subsection{Protocols and Interfaces}

Many languages and systems provide ways of defining \strong{interfaces} that
components provide or require.  Some mechanisms are purely for documentation,
others are used at runtime to obtain or verify an implementation.  Typically,
interfaces are formal, intended for compiler-verified static type checking.

As a dynamic language, Python more often uses a looser notion of interface,
known as a \strong{protocol}.  While protocols are often very precisely
specified, their intended audience is a human reader or developer, not a
compiler or automated verification tool.

Automated verification tools, however, usually extract a high overhead cost
from developers.  The Java language, for example, requires that all methods
of an interface be defined by a class that claims to implement the
interface, even if those methods are never used in the program being
compiled!  And yet, the more important \emph{dynamic} behavior of the
interface at runtime is not captured or verifiable by the compiler, so written
documentation for human readers is still required!

In the Python language, the primary uses for objects representing protocols
or interfaces are at runtime, rather than at compile time.  Typically, such
objects are used to ask for an implementation of the interface, or supplied
by an object to claim that it supports that interface.

In principle, any Python object may be used as a \strong{protocol object}.
However, for a variety of practical reasons, it is best that protocol objects
be hashable and comparable.  That is, protocol objects should be usable as
dictionary keys.

This still allows for a wide variety of protocol object implementations,
however.  One might assign meaning to the number 42, for example, as
referring to some hypothetical ``hitchhiker'' protocol.  More realistically,
the Microsoft COM framework uses UUIDs (Universally Unique Identifiers) to
identify interfaces.  UUIDs can be represented as Python strings, and thus
are usable as protocol objects.

But a simple string or number is often not very useful as a protocol
object.  Aside from the issue of how to assign strings or numbers to
protocols, these passive protocol objects cannot \emph{do} anything, and by
themselves they document nothing.

There are thus two more common approaches to creating protocol objects in
Python: classes (such as abstract base classes or ``ABCs''), and \strong{
interface objects}.  Interface objects are typically also defined using Python
\code{class} statements, but use a custom metaclass to create an object
that may not be usable in the same ways as a ``real'' Python class.  Many
Python frameworks (such as Twisted, Zope, and this package) provide their own
framework-specific implementations of this ``interface object'' approach.

Since classes and most interface object implementations can be used as
dictionary keys, and because their Python source code can serve as (or
be converted to) useful documentation, both of these approaches are viable
ways to create protocol objects usable with the \module{protocols} package.

In addition, inheriting from a class or interface objects is a simple way to
define implication relationships between protocol objects.  Inheriting from a
protocol to create a new protocol means that the new protocol \strong{implies}
the old protocol.  That is, any implementation or adaptation to the new
protocol, is implied to be usable in a place where the old protocol was
required.  (We will have more to say about direct and adapted implication
relationships later on, in section \ref{proto-implication}.)

At this point, we still haven't described any mechanisms for making adapters
available, or declaring what protocols are supported by a class or object
To do that, we need to define two additional kinds of protocol objects, that
have more specialized abilities.

An \strong{adapting protocol} is a protocol object that is potentially able to
adapt components to support the protocol it represents, or at least to
recognize that a component supports (or claims to support) the protocol.  To
do this, an adapting protocol must have an \function{__adapt__} method, as
will be described in section \ref{adapt-protocol}.  (Often, this method
can be added to an existing class, or patched into an interface object
implementation.)

An \strong{open protocol} is an adapting protocol that is also capable of
accepting adapter declarations, and managing its implication relationships
with other protocols.  Open protocols can be used with this package's
protocol declaration API, as long as they implement (or can be adapted to)
the \class{IOpenProtocol} interface, as will be described in section
\ref{open-protocols}.

Whether a protocol object is as simple as a string, or as complex as an
open protocol, it can be used to request that a component support
(or adapt to) the protocol that it symbolizes.  In the next section, we'll
look at how to make such a request, and how the different kinds of protocol
objects participate (or not) in fulfilling such requests.


\subsection{\function{adapt()} and the Adaptation Protocol
\label{adapt-protocol}}

Component adaptation is the central focus of the \module{protocols} package.
All of the package's protocol declaration API depends on component adaptation
in order to function, and the rest of the package is just there to make it
easier for developers to use component adaptation in their frameworks and
programs.

Component adaptation is performed by calling the \function{adapt()} function,
whose design is based largely on the specification presented in \pep{246}:

\begin{funcdesc}{adapt}{component, protocol,
\optional{, default \optional{, factory}}}

Return an implementation of \var{protocol} (a protocol object) for
\var{component} (any object).  The implementation returned may be
\var{component}, or an adapter that implements the protocol on its
behalf.  If no implementation is available, return \var{default}.  If no
\var{default} is provided, call \code{\var{factory}(\var{component},
\var{protocol})} and return the result.  If no \var{factory} is supplied,
raise \exception{NotImplementedError}.

\var{default} may be supplied as a positional or keyword argument.
\var{factory}, however, must be supplied as a keyword argument in order
to be used.

\end{funcdesc}

The component adaptation process performed by \function{adapt()} proceeds
in four steps:

\begin{enumerate}

\item If the protocol is a class or type, and the component is an instance
of that class or type, the component is returned unchanged.  (This quickly
disposes of the most trivial cases).

\item If the component has a \function{__conform__} method, it is called,
passing in the protocol.  If the method returns a value other than
\constant{None}, it is returned as the result of \function{adapt()}.

\item If the protocol has an \function{__adapt__} method, it is called,
passing in the component.  If the method returns a value other than
\constant{None}, it is returned as the result of \function{adapt()}.

\item Perform default processing as described above, returning \var{default},
invoking \var{factory}, or raising \exception{NotImplementedError} as
appropriate.

\end{enumerate}

This four-step process is called the \strong{adaptation protocol}.  Note
that it can be useful even in the case where neither the component nor the
protocol object are aware that the adaptation protocol exists, and it
gracefully degrades to a kind of \function{isinstance()} check in that
case.  However, if either the component or the protocol object has been
constructed (or altered) so that it has the appropriate \function{__conform__}
or \function{__adapt__} method, then much more meaningful results can be
achieved.

Component adaptation is intended to completely replace all non-cooperative
introspection techniques, such as \function{type()}, \function{isinstance()},
\function{hasattr()}, and even interface checks.  Such introspection
tends to limit framework flexibility by unnecessarily closing policies to
extension by end users.  It often makes code maintenance more difficult as
well, since such checks are often performed in more than one place, and
must be kept in sync whenever a new interface or type must be checked.

The common use cases for such introspection are:

\begin{itemize}

\item To manually adapt a supplied component to a needed interface

\item To select one of several possible behaviors, based on the kind of
component supplied

\item To select another component, or take some action, using information
about the interfaces supported by the supplied component

\end{itemize}

Obviously, the first case is handled quite well by \function{adapt()}, at
least in an environment where it's easy to declare adapters between types and
protocols.  The second and third cases may at first seem to demand an ability
to introspect what interfaces are supported by a component.  But, as we'll
see later, they are almost always better served by defining new protocols
that supply the required behavior or metadata, and then requesting
implementations of those protocols.

In all three use cases, replacing introspection with adaptation opens the
framework to third party extensions, without further modifications being
required -- and without the need to do extensive design or documentation
of a new hook or extension point to be added to the framework.  Indeed,
the availability of a standard mechanism for adaptation means that the
extension mechanism need only be documented once: right here in this
document.

In section \ref{introspect-elim}, we will present examples of how to
refactor all three kinds of introspection code to purely adaptation-driven
code, showing how the flexibility and readability of the code improves in the
process.  But first, we will need to cover how protocols and interfaces can
be defined, declared, and adapted, using the API provided by the
\module{protocols} package.



\subsubsection{Differences Between \function{protocols.adapt()} and \pep{246}}

If you have read \pep{246} or are looking for an exact implmentation of it,
you should know that there are a few differences between the \module{protocols}
implementation of \function{adapt()} and the \pep{246} specification.  If you
don't care about these differences, you can skip this mini-appendix and
proceed directly to section \ref{protocols-defining}, ``Defining Interfaces
and Protocols''.

The first difference is that \exception{TypeError} is treated differently in
each implementation.  \pep{246} says that if a \function{__conform__} or
\function{__adapt__} method raises a \exception{TypeError}, it should be
treated in the same way as if the method returned \constant{None}.  This was
a workaround for the issue of accidentally calling an unbound class
method, in the case where a component or protocol supplied to
\function{adapt()} was a class.

The \module{protocols} implementation of \function{adapt()} attempts to catch
such errors also, but will reraise any exception that appears to come from
\emph{within} the execution of the \function{__conform__} or
\function{__adapt__} method.  So if these methods raise a \exception{TypeError},
it will be passed through to the caller of \function{adapt}.  Thus, if you
are writing one of these methods, you should not raise a \exception{TypeError}
to signal the lack of an adaptation.  Rather, you should return \constant{None}.

Second, \exception{NotImplementedError} is raised when no adaptation is
found, and no default is supplied, rather than the \exception{TypeError}
specified by \pep{246}.  And third, \function{protocols.adapt()} has an optional
\var{factory} argument that the \pep{246} \function{adapt()} does not.

These differences are the result of experience using the \module{protocols}
package with PEAK, and advances in the Python state-of-the-art since
\pep{246} was written (over two years ago).  We believe that they make the
adaptation protocol more robust, more predictable, and easier to use for
its most common applications.


\subsection{Defining Interfaces and Protocols \label{protocols-defining}}

Protocol

InterfaceClass

Interface

IAdaptingProtocol

IOpenProtocol

\subsection{Creating and Using Adapters}

IAdapterFactory

NO_ADAPTER_NEEDED

DOES_NOT_SUPPORT


\subsection{The Core Declaration API}

declareAdapterForType

declareAdapterForProtocol

declareAdapterForObject


\subsection{Protocol Implication \label{proto-implication}}

subsetting, extending...

\subsection{The Convenience Declaration API}

declareAdapter

declareImplementation

adviseObject


\subsection{Convenience Declarations in Class, Protocol and Module Bodies}

advise

\subsection{The \class{IOpenProtocol} Interface \label{open-protocols}}

IOpenProtocol

metaclass issues, fwd ref to metamethod and supermeta

\subsection{Protocols and Types}

IOpenImplementor

\subsection{Protocols and Instances}

IOpenProvider

\subsection{Examples}
\subsubsection{Replacing introspection with Adaptation \label{introspect-elim}}

\subsection{Advanced Techniques}
\subsubsection{Instance-specific Declarations}
\subsubsection{Custom Declaration Mechanisms}
\subsubsection{Adapting ``Foreign'' Interfaces}

\subsection{Module Contents}

Attribute

\module{protocols.classic}

\module{protocols.adapters} -- "adapter arithmetic"

minimumAdapter

composeAdapters

updateWithSimplestAdapter

\module{protocols.advice}

metamethod

supermeta

addClassAdvisor, isClassAdvisor, getFrameInfo
